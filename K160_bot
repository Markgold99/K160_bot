import telebot
from telebot import types

# Замените 'ВАШ_ТОКЕН_БОТА' на ваш реальный токен
TOKEN = '8480164746:AAEXHiu_jQQsE_f3_47FTHBLPXhfYbanhzM'

bot = telebot.TeleBot(TOKEN)

# Словарь для хранения состояния каждого пользователя
user_states = {}

# Обработчик команды /start
@bot.message_handler(commands=['start'])
def send_welcome(message):
    bot.reply_to(message, "Привет! Я бот для приёма заказов. Чтобы начать, введите команду /order.")

# ---
# Логическая цепочка для оформления заказа
# ---

# Шаг 1: Команда, запускающая цепочку
@bot.message_handler(commands=['order'])
def start_order(message):
    chat_id = message.chat.id
    user_states[chat_id] = {'step': 'awaiting_product'}
    bot.send_message(chat_id, "Что вы хотите заказать?")

# Шаг 2: Получение названия товара
@bot.message_handler(func=lambda message: user_states.get(message.chat.id, {}).get('step') == 'awaiting_product')
def get_product(message):
    chat_id = message.chat.id
    product_name = message.text
    user_states[chat_id]['product'] = product_name
    user_states[chat_id]['step'] = 'awaiting_quantity'
    bot.send_message(chat_id, f"Вы выбрали '{product_name}'. Сколько штук?")

# Шаг 3: Получение количества и завершение цепочки
@bot.message_handler(func=lambda message: user_states.get(message.chat.id, {}).get('step') == 'awaiting_quantity')
def get_quantity(message):
    chat_id = message.chat.id
    try:
        quantity = int(message.text)
        product_name = user_states[chat_id]['product']
        
        # Завершаем цепочку и очищаем состояние, чтобы избежать зацикливания
        del user_states[chat_id]
        
        bot.send_message(chat_id, f"Отлично! Ваш заказ: {quantity} шт. '{product_name}' принят. Чтобы сделать новый заказ, введите /order.")
    except (ValueError, KeyError):
        bot.send_message(chat_id, "Пожалуйста, введите число. Если хотите отменить, введите /start.")

# Запуск бота
print("Бот запущен. Нажмите кнопку 'Play' ещё раз, чтобы остановить.")
bot.infinity_polling()
